<!DOCTYPE html>
<html lang="en">
<head>
    <title>Three.js - Protein Path Visualizer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            background-color: #000000;
            color: #fff;
            font-family: sans-serif;
            overflow: hidden;
        }
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background-color: rgba(30, 30, 30, 0.85);
            border: 1px solid #555;
            border-radius: 8px;
            width: 320px;
            z-index: 100;
        }
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        .control-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        h4 {
            margin-top: 0;
            color: #00aaff;
        }
        label, button {
            display: block;
            width: 100%;
            margin-top: 10px;
            text-align: left;
        }
        button {
            padding: 12px;
            background-color: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            text-align: center;
        }
        button:hover {
            background-color: #444;
        }
        button:disabled {
            background-color: #222;
            color: #666;
            cursor: not-allowed;
        }
        input[type="range"] {
            width: 100%;
        }
        #uploadBtn {
            background-color: #0066aa;
        }
        #zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            z-index: 101;
        }
        .zoom-btn {
            width: 50px;
            height: 50px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            margin-top: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #zoomInBtn {
            background-color: rgba(0, 200, 0, 0.5);
        }
        #zoomOutBtn {
            background-color: rgba(200, 0, 0, 0.5);
        }
        #log-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 420px;
            height: calc(100vh - 40px);
            background-color: rgba(10, 10, 10, 0.8);
            border: 1px solid #555;
            border-radius: 8px;
            z-index: 100;
            display: none;
            flex-direction: column;
            padding: 10px;
            box-sizing: border-box;
        }
        #log-panel h4 {
            margin-top: 0;
            text-align: center;
            flex-shrink: 0;
        }
        #log-list {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            flex-grow: 1;
            font-family: 'Courier New', Courier, monospace;
            font-size: 13px;
        }
        #log-list li {
            padding: 4px;
            border-bottom: 1px solid #333;
            white-space: pre;
        }
        #log-list li:first-child {
            background-color: rgba(0, 255, 255, 0.1);
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="info-panel">
        <div class="control-group">
            <h4>1. Load Protein Path</h4>
            <button id="uploadBtn">Choose Path File (.glb)</button>
            <input type="file" id="fileInput" accept=".glb" style="display: none;">
        </div>
        <div class="control-group">
            <h4>2. Simulation Controls</h4>
            <button id="simulateBtn" disabled>Start Simulation</button>
            <button id="logBtn" disabled>Start Logging Path Info</button>
            <label for="speedSlider">Particle Speed: <span id="speedValue">1.0</span></label>
            <input type="range" id="speedSlider" min="0.1" max="5" step="0.1" value="1.0" disabled>
        </div>
        <div class="control-group">
            <h4>3. Visualization</h4>
            <button id="generate3DBtn" disabled>Generate 3D Shell</button>
            <button id="flyInsideBtn" disabled>Fly Inside 3D</button>
            <button id="moveWithParticleBtn" disabled>Move with Particle</button>
            <button id="trackRotateBtn" disabled>Track Particle with Rotating Object</button>
            <button id="generalViewBtn" disabled>General Perspective</button>
        </div>
    </div>
    
    <div id="log-panel">
        <h4>Path Data Log</h4>
        <ul id="log-list"></ul>
    </div>

    <div id="zoom-controls">
        <button id="zoomInBtn" class="zoom-btn">+</button>
        <button id="zoomOutBtn" class="zoom-btn">-</button>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.138.0/build/three.module.js",
                "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.138.0/examples/jsm/controls/OrbitControls.js",
                "three/examples/jsm/loaders/GLTFLoader.js": "https://unpkg.com/three@0.138.0/examples/jsm/loaders/GLTFLoader.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

        let scene, camera, renderer, controls;
        let particle, pathCurve, pathObject, tubeShell;
        let isSimulating = false, isLogging = false;
        let particleProgress = 0, particleDirection = 1, speedFactor = 1.0;
        let cameraMode = 'general';
        let clock = new THREE.Clock();
        const trailSegments = [];
        let pathData = [];
        const logHistory = [];
        const MAX_LOG_HISTORY = 40;

        const loader = new GLTFLoader();
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const simulateBtn = document.getElementById('simulateBtn');
        const logBtn = document.getElementById('logBtn');
        const logPanel = document.getElementById('log-panel');
        const logList = document.getElementById('log-list');
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        const generate3DBtn = document.getElementById('generate3DBtn');
        const flyInsideBtn = document.getElementById('flyInsideBtn');
        const moveWithParticleBtn = document.getElementById('moveWithParticleBtn');
        const trackRotateBtn = document.getElementById('trackRotateBtn');
        const generalViewBtn = document.getElementById('generalViewBtn');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 20, 50);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            setupUIListeners();
            animate();
        }

        function setupUIListeners() {
            uploadBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);
            simulateBtn.addEventListener('click', toggleSimulation);
            logBtn.addEventListener('click', toggleLogging);
            speedSlider.addEventListener('input', (e) => {
                speedFactor = parseFloat(e.target.value);
                speedValue.textContent = speedFactor.toFixed(1);
            });
            generate3DBtn.addEventListener('click', createTubeShell);
            flyInsideBtn.addEventListener('click', () => setCameraMode('fly'));
            moveWithParticleBtn.addEventListener('click', () => setCameraMode('road'));
            trackRotateBtn.addEventListener('click', () => setCameraMode('track_rotate'));
            generalViewBtn.addEventListener('click', () => setCameraMode('general'));
            zoomInBtn.addEventListener('click', () => camera.position.multiplyScalar(0.8));
            zoomOutBtn.addEventListener('click', () => camera.position.multiplyScalar(1.2));
        }

        function toggleLogging() {
            isLogging = !isLogging;
            logBtn.textContent = isLogging ? 'Stop Logging Path Info' : 'Start Logging Path Info';
            logPanel.style.display = isLogging ? 'flex' : 'none';
            if (!isLogging) {
                logHistory.length = 0;
                logList.innerHTML = '';
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                loader.parse(e.target.result, '', (gltf) => {
                    if (pathObject) scene.remove(pathObject);
                    if (particle) scene.remove(particle);
                    if (tubeShell) scene.remove(tubeShell);
                    if (trailSegments.length > 0) clearTrail();
                    pathData = [];
                    
                    const pathMesh = gltf.scene.children[0];
                    if (!pathMesh || !pathMesh.isMesh) return;

                    const positions = pathMesh.geometry.attributes.position;
                    const colors = pathMesh.geometry.attributes.color;
                    const pointsForCurve = [];
                    
                    for (let i = 0; i < positions.count; i++) {
                        const point = new THREE.Vector3().fromBufferAttribute(positions, i);
                        pointsForCurve.push(point);
                        let colorData = colors ? new THREE.Color().fromBufferAttribute(colors, i) : null;
                        pathData.push({ point, color: colorData });
                    }
                    
                    if (pointsForCurve.length < 2) return;

                    pathCurve = new THREE.CatmullRomCurve3(pointsForCurve);
                    
                    createGlowingPathObject();
                    createParticle();
                    
                    simulateBtn.disabled = false;
                    logBtn.disabled = false;
                    speedSlider.disabled = false;
                    generate3DBtn.disabled = false;
                    moveWithParticleBtn.disabled = false;
                    trackRotateBtn.disabled = false;
                    generalViewBtn.disabled = false;
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function createGlowingPathObject() {
            const points = pathCurve.getPoints(500);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const progress = new Float32Array(points.length);
            for (let i = 0; i < points.length; i++) progress[i] = i / (points.length - 1);
            geometry.setAttribute('progress', new THREE.BufferAttribute(progress, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    baseColor: { value: new THREE.Color(0x00ffff) },
                    glowColor: { value: new THREE.Color(0xff0000) },
                    particleProgress: { value: 0.0 },
                    particleDirection: { value: 1.0 }
                },
                vertexShader: `
                    attribute float progress;
                    varying float vProgress;
                    void main() {
                        vProgress = progress;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 baseColor;
                    uniform vec3 glowColor;
                    uniform float particleProgress;
                    uniform float particleDirection;
                    varying float vProgress;
                    void main() {
                        float glowStart = particleProgress;
                        float glowEnd = particleProgress + (0.15 * particleDirection);
                        if (particleDirection < 0.0) { float temp = glowStart; glowStart = glowEnd; glowEnd = temp; }
                        float intensity = 0.0;
                        if (vProgress >= glowStart && vProgress <= glowEnd) {
                            float dist = abs(vProgress - particleProgress);
                            intensity = 1.0 - smoothstep(0.0, 0.15, dist);
                        }
                        vec3 finalColor = mix(baseColor, glowColor, intensity);
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `
            });

            pathObject = new THREE.Line(geometry, material);
            new THREE.Box3().setFromObject(pathObject).getCenter(pathObject.position).multiplyScalar(-1);
            scene.add(pathObject);
        }

        function createParticle() {
            if (particle) scene.remove(particle);
            const particleGeo = new THREE.SphereGeometry(0.4, 32, 32); 
            const particleMat = new THREE.MeshStandardMaterial({ 
                color: 0xff0000, 
                emissive: 0xff0000, 
                emissiveIntensity: 3 
            });
            particle = new THREE.Mesh(particleGeo, particleMat);
            scene.add(particle);
            particleProgress = 0;
            updateParticlePosition();
        }

        function toggleSimulation() {
            isSimulating = !isSimulating;
            simulateBtn.textContent = isSimulating ? 'Stop Simulation' : 'Start Simulation';
        }

        function createTubeShell() {
            if (!pathCurve) return;
            if (tubeShell) scene.remove(tubeShell);
            const tubeGeo = new THREE.TubeGeometry(pathCurve, 200, 1.2, 16, false); 
            const tubeMat = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            tubeShell = new THREE.Mesh(tubeGeo, tubeMat);
            tubeShell.position.copy(pathObject.position);
            scene.add(tubeShell);
            generate3DBtn.disabled = true;
            flyInsideBtn.disabled = false;
        }

        function setCameraMode(mode) {
            cameraMode = mode;
            controls.enabled = (mode === 'general' || mode === 'track_rotate');
            if (mode === 'general' && pathObject) {
                const center = new THREE.Vector3();
                new THREE.Box3().setFromObject(pathObject).getCenter(center);
                controls.target.copy(center);
            }
            generalViewBtn.disabled = (mode === 'general');
            flyInsideBtn.disabled = (mode === 'fly' || tubeShell === null);
            moveWithParticleBtn.disabled = (mode === 'road');
            trackRotateBtn.disabled = (mode === 'track_rotate');
        }

        function updateParticlePosition() {
            if (!pathCurve || !particle) return;
            const position = pathCurve.getPointAt(particleProgress);
            if (position) {
                particle.position.copy(position.add(pathObject.position));
            }
        }

        function updateTrail() {
            if (!particle) return;
            const trailMaterial = new THREE.LineBasicMaterial({
                color: particle.material.color,
                transparent: true,
                opacity: 1.0,
                linewidth: 4
            });
            const lastPoint = trailSegments.length > 0 ? trailSegments[trailSegments.length - 1].endPoint : particle.position;
            const trailGeometry = new THREE.BufferGeometry().setFromPoints([lastPoint.clone(), particle.position.clone()]);
            const trailLine = new THREE.Line(trailGeometry, trailMaterial);
            const segment = { line: trailLine, life: 180.0, endPoint: particle.position.clone() };
            trailSegments.push(segment);
            scene.add(trailLine);
        }

        function clearTrail() {
            trailSegments.forEach(segment => scene.remove(segment.line));
            trailSegments.length = 0;
        }

        function getStructureTypeFromColor(color) {
            if (!color) return 'N/A';
            const hsl = {};
            color.getHSL(hsl);
            if (hsl.s < 0.2 && hsl.l > 0.4) return 'Carbon (C)';
            if (hsl.h > 0.55 && hsl.h < 0.7 && hsl.s > 0.5) return 'Nitrogen (N)';
            if ((hsl.h > 0.95 || hsl.h < 0.05) && hsl.s > 0.7) return 'Oxygen (O)';
            if (hsl.h > 0.13 && hsl.h < 0.18 && hsl.s > 0.7) return 'Sulfur (S)';
            if (hsl.h > 0.8 && hsl.s > 0.5) return 'Helix (Alpha)';
            if (hsl.h > 0.4 && hsl.h < 0.55 && hsl.s > 0.5) return 'Sheet (Beta)';
            return 'Loop/Unknown';
        }

        function formatColorForLog(color) {
            if (!color) return 'N/A'.padEnd(17);
            const r = Math.round(color.r * 255);
            const g = Math.round(color.g * 255);
            const b = Math.round(color.b * 255);
            return `[${r.toString().padEnd(3)},${g.toString().padEnd(3)},${b.toString().padEnd(3)}]`.padEnd(17);
        }

        // --- FIX: Added the missing updateLogDisplay function ---
        function updateLogDisplay() {
            logList.innerHTML = '';
            logHistory.forEach(entry => {
                const li = document.createElement('li');
                li.textContent = entry;
                logList.appendChild(li);
            });
        }
        // --- END FIX ---

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            for (let i = trailSegments.length - 1; i >= 0; i--) {
                const segment = trailSegments[i];
                segment.life -= delta;
                if (segment.life <= 0) {
                    scene.remove(segment.line);
                    trailSegments.splice(i, 1);
                } else {
                    segment.line.material.opacity = segment.life / 180.0;
                }
            }
            if (isSimulating && particle && pathCurve) {
                particleProgress += (delta * 0.05 * speedFactor) * particleDirection;
                if (particleProgress >= 1 || particleProgress <= 0) {
                    particleDirection *= -1;
                    particle.material.color.setHSL(Math.random(), 1.0, 0.5);
                    particle.material.emissive.copy(particle.material.color);
                    particleProgress = Math.max(0, Math.min(1, particleProgress));
                }
                updateParticlePosition();
                updateTrail();

                if (pathObject && pathObject.material.isShaderMaterial) {
                    pathObject.material.uniforms.particleProgress.value = particleProgress;
                    pathObject.material.uniforms.particleDirection.value = particleDirection;
                }

                if (isLogging) {
                    const currentIndex = Math.round(particleProgress * (pathData.length - 1));
                    const currentData = pathData[currentIndex];
                    if (currentData) {
                        const pos = currentData.point;
                        const interpretedType = getStructureTypeFromColor(currentData.color);
                        const colorString = formatColorForLog(currentData.color);

                        const logString = `Index: ${currentIndex.toString().padEnd(5)} Type: ${interpretedType.padEnd(14)} Color: ${colorString} Pos: [${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}]`;

                        if (logHistory.length === 0 || logHistory[0] !== logString) {
                            logHistory.unshift(logString);
                            if (logHistory.length > MAX_LOG_HISTORY) logHistory.pop();
                            updateLogDisplay();
                        }
                    }
                }
            }

            if (cameraMode === 'fly' || cameraMode === 'road') {
                 if (particle && pathCurve) {
                    const lookAheadProgress = particleProgress + (0.02 * particleDirection);
                    const lookAtPoint = pathCurve.getPointAt(Math.max(0, Math.min(1, lookAheadProgress)));
                    if (lookAtPoint) {
                        lookAtPoint.add(pathObject.position);
                        let cameraPosition = new THREE.Vector3();
                        if (cameraMode === 'fly') {
                            const tangent = pathCurve.getTangentAt(particleProgress).normalize();
                            const offset = tangent.multiplyScalar(-8).add(new THREE.Vector3(0, 2, 0));
                            cameraPosition.copy(particle.position).add(offset);
                        } else { 
                            const backPointProgress = particleProgress - (0.015 * particleDirection);
                            const cameraBasePos = pathCurve.getPointAt(Math.max(0, Math.min(1, backPointProgress)));
                            cameraBasePos.add(pathObject.position);
                            cameraPosition.copy(cameraBasePos).add(new THREE.Vector3(0, 1.5, 0));
                        }
                        camera.position.lerp(cameraPosition, 0.1);
                        camera.lookAt(lookAtPoint);
                    }
                }
            } else if (cameraMode === 'track_rotate') {
                if (particle && pathCurve) {
                    const lookAtTarget = particle.position;
                    const lookAheadProgress = Math.min(1, particleProgress + 0.1);
                    const tangent = pathCurve.getTangentAt(lookAheadProgress).normalize();
                    const sideVector = new THREE.Vector3().crossVectors(tangent, new THREE.Vector3(0, 1, 0)).normalize();
                    if (sideVector.length() < 0.5) sideVector.set(1, 0, 0); 
                    const distance = camera.position.distanceTo(lookAtTarget);
                    const offset = sideVector.multiplyScalar(distance);
                    const desiredPosition = new THREE.Vector3().addVectors(lookAtTarget, offset);
                    camera.position.lerp(desiredPosition, 0.05);
                    camera.lookAt(lookAtTarget);
                }
                 controls.update();
            } else { 
                controls.update();
            }
            
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>```
